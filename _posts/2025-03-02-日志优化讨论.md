---
layout:     post
title:      记一次有趣的日志优化
subtitle:   日志回退讨论
date:       2025-3-2
author:     JH
header-img: img/post-bg-o.jpg
catalog: true
tags:
    - 分布式
---

> 本文记录一次分布式系统中日志回退优化的有趣讨论，包含两种主流方案的对比与代码实现思路。

## 背景

之前的日志回退方式是直接使 `nextIndex - 1`，这必然导致效率过慢。

下面是助教提到的优化方式，采用 `conflictIndex` 和 `conflictTerm`。

### 场景示例

假设如下：
- s2 提交到了 10，并且 log 追加到了 12，还没来得及复制到其他节点。
- 此时 s2 网络故障，s1 超时选举（0 1 3），成为 leader，term=5，并追加两条 log。
- s1 也故障，s3 超时选举（0 3），并追加三条 log，恰巧此时 s1、s2 恢复。

| Peer\\ index | 9 | 10 | 11 | 12 | 13 |
| ------------ | - | -- | -- | -- | -- |
| s0           | 3 | 4  |    |    |    |
| s1           | 3 | 4  | 5  | 5  |    |
| s2           | 3 | 4  | 4  | 4  |    |
| s3           | 3 | 4  | 6  | 6  | 6  |

```go
prevLogIndex = 12
prevLogTerm = 6
```

---

## 方案一：使用 conflictIndex 和 conflictTerm

- **conflictTerm**：`log[prevLogIndex].Term`
- **conflictIndex**：该 term 在日志中的第一个索引

**Follower 端**
- s0：`prevLogIndex` 超出日志长度，`conflictIndex = getLastLogIndex + 1 = 11`，`conflictTerm = none`
- s1：`conflictTerm = 5`，第一个索引 `conflictIndex = 11`
- s2：`conflictTerm = 4`，第一个索引 `conflictIndex = 10`

**Leader 端**
- 先检查 `conflictTerm`，如果找到了，设置 `nextIndex` 为超过该 term 的第一个 index，否则直接设置为 `conflictIndex`
- s0：无 `conflictTerm`，`nextIndex0 = 11, prevLogIndex = 10`
- s1：找不到 `conflictTerm`，`nextIndex1 = 11`
- s2：找到 `conflictTerm`，在 leader 里对应的 index = 10，因此 `nextIndex2 = 11`

---

## 方案二：只使用 conflictIndex

**Follower 端**
- s0：`prevLogIndex` 超出日志长度，`conflictIndex = getLastLogIndex + 1 = 11`
- s1：冲突 Term = 5，第一个索引 `conflictIndex = 11`
- s2：冲突 Term = 4，第一个索引 `conflictIndex = 10`

**Leader 端**
- 直接将 `nextIndex` 设置为 `conflictIndex`
- s0：`nextIndex0 = 11`
- s1：`nextIndex1 = 11`
- s2：`nextIndex2 = 10, prevLogIndex = 9`（相比第一种方案会多发送一个）

---

### 思考与代码实现

#### 问题一

`raft` 并不能修改已经 `commit` 的 `log`，这两种方案如何保证安全？
- 第一种方案不会去修改已 commit 的 log。
- 第二种方案，日志未冲突却有可能被截断，如何避免？

#### 问题二

再想象一种情景：

1. leader 先发出 append entry RPC1
2. 发出 append entry RPC2
3. 网络原因 RPC2 先到达，log 更新到 778
4. RPC1 到达，如果直接更新 log，可能会导致截断 log 变短（如 777），而 commit 可能已到 778，截断会导致 log 为 nil，commit 错误。

**结论：未发生冲突的日志无需更改。**

> 在截断 log 部分，不能无脑直接 prevLogIndex 后全部截取，而应从冲突处开始截取，这样才能保证安全。

#### 代码片段

```go
for index, entry := range args.Entries {
    idx := index + args.PrevLogIndex + 1
    DPrintf("idx : %d, rf.getLastLogIndex() : %d, rf.LastIncludedIndex: %d", idx, rf.getLastLogIndex(), rf.LastIncludedIndex)
    if idx > rf.getLastLogIndex() || rf.getLog(idx).Term != entry.Term {
        rf.logs = rf.subLog(-1, idx - 1)
        rf.logs = append(rf.logs, args.Entries[index:]...)
        rf.persist()
        break
    }
}
```

---

> 以上就是本次日志回退优化的全部内容，欢迎讨论与指正！
